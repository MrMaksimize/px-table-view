<link rel="import" href="hammer-import.html">
<script src="px-table-view-pull-to-refresh-behavior.js"></script>
<script type="text/javascript">


  /**
   * Easy shortener for handling adding and removing body classes.
   */
  //var bodyClass = document.body.classList;
  /**
   * Hold all of the default parameters for the module
   * @type {object}
   */
  var defaults = {
    // ID of the element holding pannable content area
    contentEl: 'content',

    // ID of the element holding pull to refresh loading area
    ptrEl: 'ptr',

  };

  /**
   * Hold all of the merged parameter and default module options
   * @type {object}
   */
  var options = {};

  /**
   * Pan event parameters
   * @type {object}
   */
  var pan = {
    enabled: false,
    distance: 0,
    startingPositionY: 0
  };



  /*


  ## Usage:

  window.onload = function () {
    WebPullToRefresh.init({
      loadingFunction: exampleLoadingFunction
    });
  };



  // Just an example loading function that returns a
  // promise that WebPullToRefresh can use.
  var exampleLoadingFunction = function () {
    var $list = document.getElementById('list');
    var $item = document.createElement('li');
    return new Promise(function (resolve, reject) {

      $item.textContent = ('Text label');
      $item.className = 'table-row table-row--tappable table-row--nav-right';
      $list.appendChild($item);

      if (true) {
        resolve($item);
      } else {
        reject();
      }
    });
  };
  */
var pxTableViewPullToRefreshBehavior = {
  properties: {
    pullToRefresh: {
      type: Boolean
    },
    // Number of pixels of panning until refresh
    distanceToRefresh: {
      type: Number,
      value: 70
    },
      // Pointer to function that does the loading and returns a promise
    loadingFunction: {
      type: Function
    },
    // Dragging resistance level
    resistance: {
      type: Number,
      value: 2.5
    }
  },

  attached: function () {
    if (this.pullToRefresh) {
      this.async(function(){
        this.toggleClass('table-view--ptr', this.pullToRefresh, this.$$('.table-view'));
        this.toggleClass('ptr', this.pullToRefresh);
        this.toggleClass('ptr__content', this.pullToRefresh, this.$.content);
        this._init();
        console.log('pxTableViewPullToRefreshBehavior.ready');
      });


    }
  },

  detached: function () {
    if (this.pullToRefresh) {
      console.log('pxTableViewPullToRefreshBehavior.detached');
    }
  },
  /**
   * Initialize pull to refresh, hammer, and bind pan events.
   *
   * @param {object=} params - Setup parameters for pull to refresh
   */
  _init: function(params){
    params = params || {};
    options = {
      contentEl: this.$.content,
      ptrEl: this.$.ptr,
      distanceToRefresh: this.distanceToRefresh,
      loadingFunction: this.loadingFunction,
      resistance: this.resistance
    };

    if (!options.contentEl || !options.ptrEl) {
      console.error('No contentEl or ptrEl', options);
      return false;
    }

    var h = new Hammer(options.contentEl);

    h.get('pan').set({
      direction: Hammer.DIRECTION_VERTICAL
    });

    h.on('panstart', this._onPanStart.bind(this));
    h.on('pandown', this._onPanDown.bind(this));
    h.on('panup', this._onPanUp.bind(this));
    h.on('panend', this._onPanEnd.bind(this));
    this.fire('ptr-ready');
  },
  /**
   * Set/remove the loading body class to show or hide the loading indicator after pull down.
   */
  _setBodyClass: function(){
    if (pan.distance > options.distanceToRefresh) {
      //bodyClass.add('ptr-refresh');
      this.toggleClass('ptr-refresh', true);
    } else {
      //bodyClass.remove('ptr-refresh');
      this.toggleClass('ptr-refresh', false);
    }
  },

    /**
     * Determine whether pan events should apply based on scroll position on panstart
     *
     * @param {object} e - Event object
     */
  _onPanStart: function(e){
    pan.startingPositionY = document.body.scrollTop;
    if (pan.startingPositionY === 0) {
      pan.enabled = true;
    }
  },
  /**
   * Handle element on screen movement when the pandown events is firing.
   *
   * @param {object} e - Event object
   */
  _onPanDown: function(e){
    if (!pan.enabled) {
      return;
    }

    e.preventDefault();
    pan.distance = e.distance / options.resistance;

    this._setContentPan();
    this._setBodyClass();
  },
  /**
   * Handle element on screen movement when the pandown events is firing.
   *
   * @param {object} e - Event object
   */
  _onPanUp: function(e){
    if (!pan.enabled || pan.distance === 0) {
      return;
    }

    e.preventDefault();

    if (pan.distance < e.distance / options.resistance) {
      pan.distance = 0;
    } else {
      pan.distance = e.distance / options.resistance;
    }
    this._setContentPan();
    this._setBodyClass();
  },
  /**
   * Determine how to animate and position elements when the panend event fires.
   *
   * @param {object} e - Event object
   */
  _onPanEnd: function(e){
    if (!pan.enabled) {
      return;
    }

    e.preventDefault();

    options.contentEl.style.transform = options.contentEl.style.webkitTransform = '';
    options.ptrEl.style.transform = options.ptrEl.style.webkitTransform = '';

    if (this.classList.contains('ptr-refresh')) {
      this._doLoading();
    } else {
      this._doReset();
    }

    pan.distance = 0;
    pan.enabled = false;
  },
  /**
   * Set the CSS transform on the content element to move it on the screen.
   */
  _setContentPan: function(e){
    this.transform(this._transformForTranslateY(pan.distance), options.contentEl);
    this.transform(this._transformForTranslateY((pan.distance - options.ptrEl.offsetHeight)), options.ptrEl);
    // Use transforms to smoothly animate elements on desktop and mobile devices
    //options.contentEl.style.transform = options.contentEl.style.webkitTransform = 'translate3d( 0, ' + pan.distance + 'px, 0 )';
    //options.ptrEl.style.transform = options.ptrEl.style.webkitTransform = 'translate3d( 0, ' + (pan.distance - options.ptrEl.offsetHeight) + 'px, 0 )';
  },
  /**
   * Position content and refresh elements to show that loading is taking place.
   */
  _doLoading: function(e){
    var self = this;
    this.toggleClass('ptr-loading', true);
    this.fire('ptr-loading');
    // If no valid loading function exists, just reset elements
    if (!this.loadingFunction) {
      return this._doReset();
    }

    // The loading function should return a promise
    var loadingPromise = this.loadingFunction();


    setTimeout(function () {
      console.log('Sho')
      // Once actual loading is complete, reset pull to refresh
      loadingPromise.then(function(){
        self.fire('ptr-complete');
        self._doReset();
      });
    }, 1000);
  },
  /**
   * Reset all elements to their starting positions before any paning took place.
   */
  _doReset: function(e){

    this.toggleClass('ptr-loading', false);
    this.toggleClass('ptr-refresh', false);
    this.toggleClass('ptr-reset', true);

    this.fire('ptr-reset');
    var bodyClassRemove = function () {
      this.toggleClass('ptr-reset', false);
      this.removeEventListener('transitionend', bodyClassRemove, false);
      this.fire('ptr-transitionend');
    };
    this.addEventListener('transitionend', bodyClassRemove, false);
  },
  /**
   * Handle transforming the table-row.
   * @param translateX
   * @returns {*}
   * @private
   */
  _transformForTranslateY: function (translateY) {
    if (translateY === null) {
      return 'translate3d(0, 0, 0)';
    }
    return 'translate3d(0, ' + translateY + 'px, 0)';
  }
};
</script>
