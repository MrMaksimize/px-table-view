<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html"/>
<dom-module id="x-element">
<style>
	:host {
		display: block;
		width: 100%;
	}
	::content [content].transition {
		transition: transform cubic-bezier(.55, 0, .1, 1) 0.3s;
	}

	:host .swipeable-container > ::content > * {
		position: absolute;
		top: 0;
		box-sizing: border-box;
	}

	:host .swipeable-container {
		position: relative;
		width: 100%;
		height: 100%;
	}

	.swipeable-container > ::content > [underlay] {
			width: 100%;
			background-color: crimson;
		@apply(--x-swipe-underlay);
	}

	.swipeable-container > ::content > [content] {
		background-color: #fff;
		width: 100%;
		will-change: transform;
		@apply(--x-swipe-content);
	}
</style>
<template>
	<div id="swipeContainer" class="swipeable-container">
		<content id="underlay" select="[underlay]"></content>
		<content id="content" select="[content]"></content>
	</div>
</template>
<script>
	var sharedPanel = null;
	function log(type, e) {
		console.log(type);
	}
	Polymer({
		is: 'x-element',
		behaviors: [Polymer.IronResizableBehavior],
		properties: {
			/**
		* If true, swiping is disabled
		*/
			disableSwipe: {
				type: Boolean,
				value: false
			},
			/**
		* If true, only swiping to the left.
		*/
			swipeLeft: {
				type: Boolean,
				value: false
			},
			/**
		* If true, only swiping to the right.
		*/
			swipeRight: {
				type: Boolean,
				value: false
			},
			/**
		* The number of pixels the swipeable content is peeking at from the screen edge
		* after being swiped to the screen edge.
		*/
			peekOffset: {
				type: Number,
				value: 50
			},
			/**
		* How many pixels needed to trigger auto-slide to the edge.
		*/
			slideOffset: {
				type: Number,
				value: 40
			},
			/**
		* If true, fade out when swiping towards the edges and fade in while swiping away from the edges.
		*/
			fade: {
				type: Boolean,
				value: false
			},
			/**
		* Whether the user is dragging the content interactively
		*/
			_dragging: {
				type: Boolean,
				value: false
			},
			/**
		* Whether the transition is enabled.
		*/
			_transition: {
				type: Boolean,
				value: false
			},
			/**
		* If true, swiping to the left is detected and it is only applied to swiping to either side.
		* Otherwise, use `swipeLeft' or 'swipeRight'.
		*/
			_slideLeft: {
				type: Boolean
			},
			/**
		* Repetitively evaluating delta of the transitions.
		*/
			_transitionDelta: {
				type: Number,
				observer: '_transitionDeltaChanged'
			},
			/**
		* If true, the `transitionDelta` meets the dragging requirements set by `peekOffset` and `slideOffset`.
		*/
			_validDelta: {
				type: Boolean,
				value: false
			},
			/**
		* If true, draggable panel is now at the edge of the screen.
		*/
			_atEdge: {
				type: Boolean,
				value: false
			},
			/**
		* Current pixel position of the draggable panel.
		*/
			_curPos: {
				type: Number
			},
			/**
		* If true, the draggable panel has been dragged.
		* It is used to ensure that the panel is dragging.
		*/
			_tracking: {
				type: Boolean,
				value: false
			},
			// Store children object via Polymer's getEffectiveChildren or getDistributedNodes;
			_content: Object
		},

		/**
	* The `edge` event is fired whenever `_atEdge` is set to true which
	* indicates that the current position of the draggable panel is now at
	* the edge of the viewport.
	*
	* @event edge
	* @detail {{message: String, target: Object::Event}}
	*/
		/**
	* The 'tap-underlay' event is fired whenever '_tapHandler' is called.
	*
	* @event tap-underlay
	* @detail {{nodeName: Object, target: Object::Event}}
	*/
		listeners: {
			'swipeContainer.track': '_onTrack',
			'swipeContainer.down': '_downHandler',
			'swipeContainer.up': '_upHandler',
			'swipeContainer.tap': '_tapHandler',
			'iron-resize': '_onIronResize'
		},
		ready: function () {
			// Avoid transition at the beginning e.g. page loads and enable transitions only after the element is rendered and ready.
			this._transition = true;
			this.setScrollDirection(this._swipeAllowed()
				? 'y'
				: 'all');
		},
		attached: function () {
			// on child element attached, inherit the height of the content.
			var _content = Polymer.dom(this.$.content).getDistributedNodes()[0];
			//log('content', _content);
			this.async(function () {
				this.style.height = _content.offsetHeight + 'px';
			}, 1);
			// save effective children object.
			this.set('_content', _content);
		},
		// Element Behaviorset
		_transitionDeltaChanged: function (newValue, oldValue) {
			if (this._swipeAllowed()) {
				/**
			* To trigger auto-swipe to the right:-
			* - newValue > oldValue
			* - newValue >= slideOffset
			*
			* else return to original position.
			*/
				if (this.swipeRight) {
					this._validDelta = this._atEdge
						? newValue <= -this.slideOffset
						: newValue >= this.slideOffset;
				}
				/**
			* To trigger auto-swipe to the left:-
			* - newValue < oldValue
			* - newValue <= -slideOffset
			*
			* else return to original position.
			*/
				if (this.swipeLeft) {
					this._validDelta = this._atEdge
						? newValue >= this.slideOffset
						: newValue <= -this.slideOffset;
				}
				/**
			* To trigger auto-swipe to either side,
			* it basically works the same as [swipeLeft] and
			* [swipeRight], just that it needs one more
			* parameter to detect if it's dragging to the left.
			*
			* Assert [slideLeft] if the left-dragging is
			* detected.
			*
			* else return to original position.
			*/
				if (!this.swipeLeft && !this.swipeRight) {
					if (newValue > oldValue) {
						this._slideLeft = false;
						this._validDelta = newValue >= this.slideOffset;
					}
					if (newValue < oldValue) {
						this._slideLeft = true;
						this._validDelta = newValue <= -this.slideOffset;
					}
				}
			}
		},
		_tapHandler: function (event) {
			log('_tapHandler', event);
			// when disableSwipe is true, only click event can be triggered!
			this.fire('tap-underlay', {
				nodeName: 'underlay',
				target: event
			});
			if (sharedPanel) {
				// release the panel after use.
				sharedPanel = null;
			}
		},
		_onTrack: function (event) {
			//	log('_onTrack', event);
			if (sharedPanel && this !== sharedPanel) {
				// release the panel.
				sharedPanel = null;
				return;
			}
			if (this._swipeAllowed()) {
				switch (event.detail.state) {
					case 'start':
						this._trackStart(event);
						break;
					case 'track':
						this._trackX(event);
						break;
					case 'end':
						this._trackEnd(event);
						break;
				}
			}
		},
		_trackStart: function (event) {
			//log('_trackStart', event);
			if (this._swipeAllowed()) {
				sharedPanel = this;
				this._dragging = true;
				if (this._dragging) {
					this.width = this._content.offsetWidth;
					this._transition = false;
				}
			}
		},
		_trackX: function (event) {
			//log('_trackX', event);
			if (this._dragging) {
				var dx = event.detail.dx,
					dragDx;
				this._transitionDelta = dx;
				dragDx = this._atEdge
					? this._curPos + dx
					: dx;
				this._tracking = true;
				this._moveDrawer(dragDx);
			}
		},
		_trackEnd: function (event) {
			log('_trackEnd', event);
			//reserve for future use.
		},
		_downHandler: function (event) {
			//	log('_downHandler', event);
			if (!this._dragging && !this.disableSwipe && !sharedPanel) {
				// cancel selection
				event.preventDefault();
				// grab this panel
				sharedPanel = this;
			}
		},
		_upHandler: function (event) {
			//	log('_upHandler', event);
			this._dragging = false;
			this._transition = true;
			/**
		* Specialty for when [AtEdge] is asserted, hold it back to the edge.
		*/
			if (this._swipeAllowed() && this._atEdge && !this._validDelta) {
				this._moveDrawer(this._curPos);
				// release the panel
				sharedPanel = null;
				return;
			}
			/**
		* tracking must be asserted.
		*/
			if (this._swipeAllowed() && this._tracking) {
				/**
			*  to swipe to the leftmost edge:-
			*  - slide until [this.peekOffset] - [this.width].
			*  - validDelta = true
			*  - AtEdge = false
			*  - store current position after swiping to leftmost edge, [curPos]
			*  - animate the dragging by [_moveDrawer(pixel_to_animate)]
			*
			*  else vice versa for swiping to rightmsot edge and/ or either side.
			*/
				var slideTo = this.width - this.peekOffset,
					offsetLR = this.swipeRight
						? slideTo
						: -slideTo,
					deltaLR;
				if (!this.swipeLeft) {
					offsetLR = this._slideLeft
						? -slideTo
						: slideTo;
				}
				deltaLR = this._validDelta && !this._atEdge
					? offsetLR
					: null;
				this._curPos = this._atEdge
					? null
					: deltaLR;
				this._atEdge = !(deltaLR === null);
				if (this._atEdge) {
					this.fire('edge', {
						message: 'panel-on-edge',
						target: event
					});
				}
				this._validDelta = false;
				this._tracking = false;
				this._moveDrawer(deltaLR);
			}
			// release the panel after use.
			sharedPanel = null;
		},
		_swipeAllowed: function () {
			return !this.disableSwipe;
		},
		_transformForTranslateX: function (translateX) {
			if (translateX === null) {
				/**
			* return 0 works smoother on mobile than returning '';
			*/
				return 'translate3d(0, 0, 0)';
			}
			return 'translate3d(' + translateX + 'px, 0, 0)';
		},
		_moveDrawer: function (translateX) {
			log('_moveDrawer', translateX);
			var _content = this._content;
			// if fade is set, transform with fading opacity.
			if (this.fade) {
				var _contentOffsetWidth = _content.offsetWidth;
				var _opacity = Math.max(0, (_contentOffsetWidth - Math.abs(translateX)) / _contentOffsetWidth);
				// translateX is null which means that swipeable content is returning to its original position hence opacity is '' or 1;
				_content.style.opacity = translateX === null
					? ''
					: _opacity;
			}
			// transform swipeable content.
			this.transform(this._transformForTranslateX(translateX), _content);
			// apply class while transforming the drawer.
			this.toggleClass('transition', this._transition, _content);
			this.toggleClass('dragging', this._dragging, _content);
			this.toggleClass('swipe-left', this.swipeLeft, _content);
			this.toggleClass('swipe-right', this.swipeRight, _content);
		},
		// Reset the position of the swipeable content with the attribute `content` from the edge after being dragged.
		resetPosition: function () {
			// this.transform(this._transformForTranslateX(null), this._content);
			this._moveDrawer(null);
			// reset position of the swipeable content from the edge.
			this.set('_atEdge', false);
			this.set('_curPos', 0);
			// fire event when position is reset.
			this.fire('position-reset');
		},
		_onIronResize: function () {
			console.log('px-swipe-resize');
			var _content = this._content;
			if (_content && this._toUpdateHeight) {
				this.async(function () {
					console.log(this._content.offsetHeight);
					this.style.height = _content.offsetHeight + 'px';
				}, 1);
			}
		}
	});
</script>

</dom-module>
